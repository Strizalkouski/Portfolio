---
layout: post
title: BlocChat - Angular JS
thumbnail-path: "img/BCMessages.png"
short-description: BlocChat - A Chat Room utilizing Firebase API!
---

{:.center}
![]({{ site.baseurl }}/img/BCModal.png)

**Summary** - 
The task of creating BlocChat is to create a Chat Room tool that can send and receive messages in Real Time.  This application will also be able to store messages so that we can go back and reference them later.  Additionally this application will utilize cookies to keep track of unique usernames, this way we have identifiers for messages.




**Explanation** -
The first picture above shows what you will see on your first visit.  The application checks your cookies to see if you have a unique username stored and set.  If you do not have a cookie containing your username, a modal will pop up requesting for you to enter your desired username.  Usernames must meet criteria and **can not** be left blank.  Once entered you are free to select a chat room from the side bar and then begin chatting!  

{:.center}
![]({{ site.baseurl }}/img/BCMessages.png)




**Problem** - 
The unique problems with designing this application are:


<ul>1. Sending and Receiving messages tied to a username</ul>
<ul>2. Linking messages to a specific room instead of just sending them to anywhere</ul>
<ul>3. Storing messages for a later date, or being able to check logs behind the scenes</ul>

Below we will cover how we solved these challenges




**Solution** -

For the topic of sending and receiving messages tied to a unique username we used cookies.  
{%highlight Angular%}
(function() {
    function CookieCtrl ($uibModalInstance, $cookies) {
        this.setUserName = function() {
            $cookies.put('blocChatCurrentUser', this.username)
            $uibModalInstance.close();
        }
    };
    
angular
    .module('bloc-chat')
    .controller('CookieCtrl', ['$uibModalInstance', '$cookies', CookieCtrl]);
})();
{%endhighlight%}
**Cookie Controller Pictured Above** _describes the behavior that should take place with the cookie_.



{%highlight javascript%}
(function() {
    function Cookies($cookies, $uibModal) {
        var currentUser = $cookies.get('blocChatCurrentUser');
        if (!currentUser || currentUser ==='') {
            $uibModal.open({
                templateUrl: '/templates/Username.html',
                controller: 'CookieCtrl as cookie',
                size: 'sm',
                backdrop: 'static',
                keyboard: false
            });
        }
 }
    
    angular
        .module('bloc-chat')
        .run (['$cookies','$uibModal', Cookies]);
})();
{%endhighlight%}
**Cookie Service Pictured Above** _Checks if a cookie exists, and prompts you to enter a username if one does not_

These cookies are stored and you can verify they exist by using developer tools or something similar.  Here is a photo showing how to do that within developer tools.

{:.center}
![]({{ site.baseurl }}/img/BlocChatCookies.png)

The next issue we should talk about has to do with messages linking to rooms rather than just being a part of everything.  This is kept track of using unique keys generated by **FireBase API**.  The following photo shows how the unique ID's are generated for each message AND the room itself.

{:.center}
![]({{ site.baseurl }}/img/FireBase.png)

The logic for both the controller and service are as follows:

{%highlight javascript%}
**Service**
(function() {
  function Message($firebaseArray) {
    var Message = {};
    var ref = firebase.database().ref().child("Messages");
    var messages = $firebaseArray(ref);
    Message.all = messages;
      
    Message.getByRoomId = function(roomId) {
        return $firebaseArray(ref.orderByChild('roomId').equalTo(roomId));
    }
    
    Message.send = function(newMessage) {
        messages.$add(newMessage);
    }

    return Message;
  }

  angular
    .module('bloc-chat')
    .factory('Message', ['$firebaseArray', Message]);
})();

**Controller** 

        this.setRoom = function(room){
            this.currentRoom=room;
            this.messages = Message.getByRoomId(this.currentRoom.$id);
        };
        
        
        this.sendMessage = function() {
            this.newMessage.roomId = this.currentRoom.$id;
            this.newMessage.sentAt = firebase.database.ServerValue.TIMESTAMP;
            this.newMessage.username = $cookies.get('blocChatCurrentUser');
            console.log(this.newMessage);
                Message.send(this.newMessage);
                this.newMessage.content="";
                
            
        }
{%endhighlight%}

Using the logic there we are able to tie each new message to a specific room key value.  Those messages are then sent and stored in that specific room and are only accessible through that room **OR** via FireBase.  That covers the storing for a later time as well as once the message enters firebase, I have not implemented an in application delete function.  This means that messages are only able to be deleted from within firebase after sent!

**Results** - As stated above once we pieced everything together we have a fully functional chat room application.  We are able to send and receive messages that are stored using FireBase API.  There is a bootstrapped Modal that check for a username cookie and requires a username should it not exist.  All messages are timestamped as well for organization sake using the built in timestamp functionality.

**Conclusion** - If an organization or club was needing a reliable chat application, this would do the trick.  Messages are stored to FireBase on the cloud meaning that you will not lose them.  It also functions in real time, so it could be a great office communication tool.  This is a nice basic build for any chat based projects I may come accross in the future!


